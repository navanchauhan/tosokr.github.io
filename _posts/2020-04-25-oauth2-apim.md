---
title: Azure API Management and OAuth 2.0   
date: 2020-04-24 12:00:00 +0000
description: How to add Web App outbound IP addresses into SQL Server firewall using Azure Resource Manager template 
categories: [API Management]
tags: [APIM,Oauth2]
header:
 teaser: "/assets/img/posts/teasers/resourceGroup.png"
---
### What are OAuth 2.0 and OpenID Connect?
>OAuth 2.0 is the industry-standard protocol for authorization. OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices. - [oauth.net](https://oauth.net/2/)

Because OAuth 2.0 is an authorization protocol, it leads to the following problems when used for authentication: 
- No standard way to get the user's information
- Every implementation is a little different
- No common set of scope

OpenID Connect is a simple identity layer built on top of the OAuth 2.0 protocol. OAuth 2.0 defines mechanisms to obtain and use access tokens to access protected resources, but it does not define standard methods to provide identity information. OpenID Connect implements authentication as an extension to the OAuth 2.0 authorization process. It provides information about the end user in the form of an id_token that verifies the identity of the user and provides basic profile information about the user.

The OpenID Connect flow look like this:

![Desktop View]({{ "/assets/img/posts/aad/OpenIDFlow.png" | relative_url }})

1. A user running a browser signs in, enters credentials, and consents to permissions.
2. The /oauth2/authorize endpoint returns id_token an authorization code to the browser.
3. The browser redirects to redirect URI (the web server).
4. The web server validates id_token and sets a session cookie.
5. The web server requests an OAuth bearer token from the /oauth2/token endpoint and provides the authorization code.
6. The /oauth2/token endpoint returns an access token and a refresh_token.
7. The web server calls a web API with token in the authorization header.
8. The web API validates token.
9. The web API returns secure data to the web server.

In OAuth 2.0, the term “grant type” refers to the way an application gets an access token. Each grant type is optimized for a particular use case. Todays best practices for usage of the grant types are: 

- Web application with server backend: authorization code flow
- Native or mobile app: authorization code with PKCE flow
- JavaScript app (Single Page Application) with API backend:
  authorization code with PKCE flow (if you can)
  implicit flow (if you must)
- Microservices and APIs: client credentials flow

#### OAuth 2.0 authorization code flow 
OAuth 2.0 authorization code grant is the authorization grant that uses two separate endpoints. The authorization endpoint is used for the user interaction phase, which results in an authorization code. The token endpoint is then used by the client for exchanging the code for an access token, and often a refresh token as well. Web applications are required to present their own application credentials to the token endpoint, so that the authorization server can authenticate the client. To authorize access to Azure AD web applications by using the OAuth 2.0 code grant flow, you need to:

1. Register your application with your Azure AD tenant (this provides an Application ID for the application, as well as enable it to receive tokens)
2. Request an authorization code (the authorization code flow begins with the client directing the user to the /authorize endpoint. The client indicates the permissions it needs to acquire from the user)
3. Use the authorization code to request an access token (include the client secret into the request, for security verification)
4. Use the access token to access the resource (add the Authorization: Bearer header in the requests)
5. Refresh the access token

The authorization code flow is illustrated in the picture above, for the Open ID Connect flow. 

#### OAuth 2.0 client cridentials flow 
OAuth 2.0 Client Credentials Grant Flow permits a web service (serving the role of a confidential client) to use its own credentials instead of impersonating a user, to authenticate when calling another web service. In this scenario, the client is typically a middle-tier web service, a daemon service, or a website. For a higher level of assurance, Azure AD also allows the calling service to use a certificate (instead of a shared secret) as a credential.

The picture illustrates how the client credentials grant flow works in Azure AD.

![Desktop View]({{ "/assets/img/posts/aad/clientCredentialsFlow.png" | relative_url }})

1. The client application authenticates to the Azure AD token issuance endpoint and requests an access token.
2. The Azure AD token issuance endpoint issues the access token.
3. The access token is used to authenticate to the secured resource.
4. Data from the secured resource is returned to the client application.

### Protecting the backend APIs with Azure API Management
When you publish APIs through API Management, it's easy and common to secure access to those APIs by using subscription keys. Developers who need to consume the published APIs must include a valid subscription key in HTTP requests when they make calls to those APIs. The APIM is doing the authorization, and you just need to enable the “Requires subscription” at the product level.
The second option is to use client certificates. You can use certificates to provide TLS mutual authentication between the client and the API gateway and configure the API Management gateway to allow only requests with certificates containing a specific thumbprint. The authorization at the gateway level is handled through inbound policies.
The third option, which is of interest in this post, is using OAuth 2.0. With Auth 2.0, the authorization is done in the inbound policy by validating the provided JWT token.  We will take a look at the two applicable flows – authorization code and client credentials.

Note: It is not clear in the official Microsoft documentation, but the Consumption tier supports OAuth 2.0. In our demo, we are going to use a consumption tier instance of APIM (1 million API calls per month free of charge ;)) 

#### APIM and authorization code flow
For this scenario, we are going to use two .NET core applications:
- Client web application - we will log in to this web application using OpenID, and acces the Todo APIs using an access token. You can download the source code of the application [here](https://github.com/tosokr/client-app-todo-api)
- Todo APIs - Web APIs with no built-in protection, exposed via Azure APIM, and protected with OAuth 2.0. We will use the hosted version of the APIs at [https://tosokr-todo-api.azurewebsites.net](https://tosokr-todo-api.azurewebsites.net) If you want, you can download the code from my [Github repository](https://github.com/tosokr/todo-api) and run it locally or host it somewhere else.

As we learned in the OAuth 2.0 authorization code flow section, we need to register our application and API in Azure AD. We will start with the Todo API:
1. In Azure AD, open App Registations
2. Select "New registration"
3. Under name, enter Todo API. Select "Accounts in this organizational directory only" for Supported account types and leave Redirect URI empty (because we are not perform authentication from the API, just authorization). Click on "Register"
4. Expose an API by adding a scope like in the picture below. Under "Who can consent?", choose Admin and users (consent is the process of a user granting authorization to an application to access protected resources on their behalf. An admin or user can be asked for consent to allow access to their organization/individual data). In our example, it is OK to enable the user to consent to this application
![Desktop View]({{ "/assets/img/posts/aad/todoApiScope.png" | relative_url }})

Next, register the client application:
1. In Azure AD, open App Registations
2. Select "New registration"
3. Under name, enter Client API. Select "Accounts in this organizational directory only" for Supported account types and leave Redirect URI empty (we will add in next steps). Click on "Register".
4. Copy the values for Application (client) ID ({your_client_id}) and Directory (tenant) ID ({your_tenant_id}), because we will need those later when we will configure the applications.
5. Select Authentication from the sidebar, and click on Add a platform. Select Web and, if you are going to run the application locally, enter the Redirect URIs (I stands for Identifier)  and Logout URLs (L stands for locator). If you are going to host the application somewhere, enter your URI/Ls. Note that we are enabling the implicit grant for ID tokens because we are using a .NET Core Web Application (as stated in the description).
 ![Desktop View]({{ "/assets/img/posts/aad/clientPermissions.png" | relative_url }}) 
6. Add the https://localhost:44321 (if running the application locally) URI under Redirect URIs
7. Select Certificates & Secrets and create a new client secret ({your_client_secret}). Copy the value after the creation, because otherwise you will not be able to see it again.

For API Management Gateway to be able to verify the access token, we need to create an OAuth 2.0 configuration:
1. Open your API Management service, and under Security select OAuth 2.0
2. Click Add to create a new configuration (you can have multiple OAuth 2.0 configurations that you can assing to different APIs)
3. Enter the following details:
- Display Name: Todo API
- Client registration page URL: https://localhost (required field, we are not gonna use it)
- Authorization grant types: Authorization code
- Authorization endpoint URL: https://login.microsoftonline.com/{your_tenant_id}/oauth2/v2.0/authorize
- Authorization request method: GET
- Token endpoint URL: https://login.microsoftonline.com/{your_tenant_id}/oauth2/v2.0/token
- Client authentication methods: In the body
- Client ID: {your_client_id}
- Client secret: {your_client_secret}
4. Click Create



### Summary
Use OAuth 2.0 for (Authorization):
- Granting access to your API
- Getting access to user data in other systems

Use OpenID Connect for (Authentication):
- Logging the user in
- Making your accounts available in other systems